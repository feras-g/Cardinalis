#version 460

#include "headers/ibl_utils.glsl"

const uint k_hammersley_samples = 64;

layout(set = 0, binding = 0) uniform sampler2D spherical_env_map;
layout(set = 0, binding = 1, rgba32) uniform readonly image2D target_diffuse;
layout(set = 0, binding = 2, rgba32) uniform readonly image2D target_specular;

layout(set = 0, binding = 3) uniform ParametersBlock
{
    vec2 image_size;                    // Size of source environment map
    vec2 inv_image_size;                // Inverse size of source environment map
    uint num_samples_diffuse;           // Number of num_samples_diffuse for importance sampling. Default : 256
    uint base_mip_diffuse;              // Mipmap level of the environment map to sample from. Default: 0 
    uint mode;                          // Whether to prefilter diffuse or specular.
    bool hammersley;
} params;

layout(push_constant) uniform PSBlock
{
    uint current_mip_level;
} push_constants;

const uint  specular_filtering_per_mip_samples[6]   = { 512, 512, 4096, 4096, 8096, 8096 };
const float specular_filtering_per_mip_roughness[6] = { 0.0, 0.2, 0.4, 0.6, 0.8, 1.0 };

vec3 prefilter_env_map_diffuse(in sampler2D env_map, vec2 image_coord)
{
    /* Compute normal vector corresponding to the env map texel at UV */
    vec3 normal = spherical_env_map_to_direction(uv);
    mat3 normal_space_to_world_space = get_normal_frame(normal);

    /* Sampling */
    uint N = params.num_samples_diffuse; 
    vec3 result = vec3(0.0);
    for(uint n = 0; n < N; n++)
    {
        vec2 random_2d_point = vec2(0);

        /* Generate a random 2D point */
        if(params.hammersley)
        {
            random_2d_point = hammersley(i, k_hammersley_samples);
        }
        else
        {
            random_2d_point = pcg3d(uvec3(image_coord, n));
        }

        /* Importance sampling */
        /* Convert to directions on the unit hemisphere */ 
        float phi = 2.0 * PI * random_2d_point.x;
        float theta = asin(sqrt(random_2d_point.y));

        /* Sample position in the local coordinate system of the normal */ 
        vec3 pos_local = spherical_coord_to_cartesian_coord(theta, phi);
        vec3 pos_world = normal_space_to_world_space * pos_local;

        /* Retrieve in the environment map the texel position corresponding the the world position of the sample */  
        vec2 uv_sampled_pos = SampleSphericalMap_YXZ(pos_world);

        /* Get radiance value at sampled pos */
        vec3 radiance = textureLod(env_map, uv_sampled_pos, params.base_mip_diffuse).rgb;

        result += radiance;
    }
    result = result / float(N);
    return result;
}

vec3 prefilter_env_map_specular(in sampler2D env_map, float roughness, vec2 image_coord)
{
    vec2 pixel_coord = uv_coord_to_pixel_coord(uv, uvec2(params.k_env_map_width, params.k_env_map_height));

    /* Compute normal vector corresponding to the env map texel at UV */
    vec3 normal = spherical_env_map_to_direction(uv);

    mat3 normal_space_to_world_space = get_normal_frame(normal);

    /* Assume normal vector and view vector have the same direction */
    vec3 view_dir = normal;
    /* Sampling */
    uint N = specular_filtering_per_mip_samples[push_constants.current_mip_level]; 
    vec3 result = vec3(0.0);
    float total_weight = 0.0;
    for(uint n = 0; n < N; n++)
    {
        /* Generate a random 2D point from a uniform distribution in [0; 1] */
        vec2 random_2d_point = vec2(0);

        /* Generate a random 2D point */
        if(params.hammersley)
        {
            random_2d_point = hammersley(i, k_hammersley_samples);
        }
        else
        {
            random_2d_point = pcg3d(uvec3(image_coord, n));
        }

        /* Importance sampling */
        /* Convert to directions on the unit hemisphere */ 
        float phi = 2.0 * PI * random_2d_point.x;
        float u = random_2d_point.y;
        float a = roughness * roughness;

        /* Sample a random halfway vector */
        float theta = acos(sqrt((1.0 - u) / (1.0+(a*a - 1.0) * u)));   

        /* Halfway vector in the local coordinate system of the normal */ 
        vec3 halfvec_local = spherical_coord_to_cartesian_coord(theta, phi);
        vec3 halfvec_world = normal_space_to_world_space * halfvec_local;

        /* Find light direction from halfway vector */
        vec3 lightdir_world = 2.0 * dot(view_dir, halfvec_world) * halfvec_world - view_dir; 

        float NoL = dot(normal, lightdir_world);

        /* Only consider light directions above surface */
        if(NoL > 0.0)
        {
            /* Retrieve in the environment map the texel position corresponding the the world position of the sample */  
            vec2 uv_sampled_pos = SampleSphericalMap_YXZ(lightdir_world);

            /* Get radiance value at sampled pos */
            vec3 radiance = textureLod(env_map, uv_sampled_pos, push_constants.current_mip_level).rgb;
            result += radiance * NoL;
            total_weight += NoL;
        }
    }

    result = result / total_weight;
    return result;
}

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main()
{
    vec2 uv = gl_GlobalInvocationId.xy * params.inv_image_size;
    vec2 image_coord = uv_coord_to_pixel_coord(uv, image_size);

    if(params.mode == 0)
    {
        vec3 color = prefilter_env_map_diffuse(spherical_env_map, image_coord);
        imageStore(target_diffuse, gl_GlobalInvocationID.xy, vec4(color, 1));
    }
    else if(params.mode == 1)
    {
        vec3 color = prefilter_env_map_specular(spherical_env_map, specular_filtering_per_mip_roughness[push_constants.current_mip_level], image_coord);
        imageStore(target_specular, gl_GlobalInvocationID.xy, vec4(color, 1));
    }

    
}

